"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const defaultLogger = require("../common/console-logger");
const bucket_boundaries_1 = require("./bucket-boundaries");
const recorder_1 = require("./recorder");
const types_1 = require("./types");
const RECORD_SEPARATOR = String.fromCharCode(30);
const UNIT_SEPARATOR = String.fromCharCode(31);
// String that has only printable characters
const invalidString = /[^\u0020-\u007e]/;
class BaseView {
    /**
     * Creates a new View instance. This constructor is used by Stats. User should
     * prefer using Stats.createView() instead.
     * @param name The view name
     * @param measure The view measure
     * @param aggregation The view aggregation type
     * @param tagsKeys The Tags' keys that view will have
     * @param description The view description
     * @param bucketBoundaries The view bucket boundaries for a distribution
     * aggregation type
     * @param logger
     */
    constructor(name, measure, aggregation, tagsKeys, description, bucketBoundaries, logger = defaultLogger) {
        /**
         * A map of stringified tags representing columns labels or tag keys, concept
         * similar to dimensions on multidimensional modeling, to AggregationData.
         * If no Tags are provided, then, all data is recorded in a single
         * aggregation.
         */
        this.rows = {};
        /** true if the view was registered */
        this.registered = false;
        if (aggregation === types_1.AggregationType.DISTRIBUTION && !bucketBoundaries) {
            throw new Error('No bucketBoundaries specified');
        }
        this.logger = logger.logger();
        this.name = name;
        this.description = description;
        this.measure = measure;
        this.columns = tagsKeys;
        this.aggregation = aggregation;
        this.startTime = Date.now();
        this.bucketBoundaries = new bucket_boundaries_1.BucketBoundaries(bucketBoundaries);
    }
    /** Gets the view's tag keys */
    getColumns() {
        return this.columns;
    }
    /**
     * Records a measurement in the proper view's row. This method is used by
     * Stats. User should prefer using Stats.record() instead.
     *
     * Measurements with measurement type INT64 will have its value truncated.
     * @param measurement The measurement to record
     */
    recordMeasurement(measurement) {
        // Checks if measurement has valid tags
        if (this.invalidTags(measurement.tags)) {
            return;
        }
        // Checks if measurement has all tags in views
        for (const tagKey of this.columns) {
            if (!Object.keys(measurement.tags).some((key) => key === tagKey)) {
                return;
            }
        }
        const encodedTags = this.encodeTags(measurement.tags);
        if (!this.rows[encodedTags]) {
            this.rows[encodedTags] = this.createAggregationData(measurement.tags);
        }
        recorder_1.Recorder.addMeasurement(this.rows[encodedTags], measurement);
    }
    /**
     * Encodes a Tags object into a key sorted string.
     * @param tags The tags to encode
     */
    encodeTags(tags) {
        return Object.keys(tags)
            .sort()
            .map(tagKey => {
            return tagKey + UNIT_SEPARATOR + tags[tagKey];
        })
            .join(RECORD_SEPARATOR);
    }
    /**
     * Checks if tag keys and values have only printable characters.
     * @param tags The tags to be checked
     */
    invalidTags(tags) {
        return Object.keys(tags).some(tagKey => {
            return invalidString.test(tagKey) || invalidString.test(tags[tagKey]);
        });
    }
    /**
     * Creates an empty aggregation data for a given tags.
     * @param tags The tags for that aggregation data
     */
    createAggregationData(tags) {
        const aggregationMetadata = { tags, timestamp: Date.now() };
        const { buckets, bucketCounts } = this.bucketBoundaries;
        switch (this.aggregation) {
            case types_1.AggregationType.DISTRIBUTION:
                return Object.assign({}, aggregationMetadata, { type: types_1.AggregationType.DISTRIBUTION, startTime: this.startTime, count: 0, sum: 0, max: Number.MIN_SAFE_INTEGER, min: Number.MAX_SAFE_INTEGER, mean: null, stdDeviation: null, sumSquaredDeviations: null, buckets,
                    bucketCounts });
            case types_1.AggregationType.SUM:
                return Object.assign({}, aggregationMetadata, { type: types_1.AggregationType.SUM, value: 0 });
            case types_1.AggregationType.COUNT:
                return Object.assign({}, aggregationMetadata, { type: types_1.AggregationType.COUNT, value: 0 });
            default:
                return Object.assign({}, aggregationMetadata, { type: types_1.AggregationType.LAST_VALUE, value: undefined });
        }
    }
    /**
     * Returns a snapshot of an AggregationData for that tags/labels values.
     * @param tags The desired data's tags
     */
    getSnapshot(tags) {
        return this.rows[this.encodeTags(tags)];
    }
}
exports.BaseView = BaseView;
//# sourceMappingURL=view.js.map