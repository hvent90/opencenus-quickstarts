"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const instrumentation_http_1 = require("@opencensus/instrumentation-http");
const shimmer = require("shimmer");
const url = require("url");
const uuid = require("uuid");
/** Http2 instrumentation plugin for Opencensus */
class Http2Plugin extends instrumentation_http_1.HttpPlugin {
    /** Constructs a new Http2Plugin instance. */
    constructor() {
        super('http2');
    }
    /**
     * Patches HTTP2 incoming and outcoming request functions.
     */
    applyPatch() {
        shimmer.wrap(this.moduleExports, 'createServer', this.getPatchCreateServerFunction());
        shimmer.wrap(this.moduleExports, 'createSecureServer', this.getPatchCreateServerFunction());
        shimmer.wrap(this.moduleExports, 'connect', this.getPatchConnectFunction());
        return this.moduleExports;
    }
    /** Unpatches all HTTP2 patched function. */
    applyUnpatch() {
        // Only Client and Server constructors will be unwrapped. Any existing
        // Client or Server instances will still trace
        shimmer.unwrap(this.moduleExports, 'createServer');
        shimmer.unwrap(this.moduleExports, 'createSecureServer');
        shimmer.unwrap(this.moduleExports, 'connect');
    }
    getPatchConnectFunction() {
        const plugin = this;
        return (original) => {
            return function patchedConnect(authority) {
                const client = original.apply(this, arguments);
                shimmer.wrap(client, 'request', (original) => (plugin.getPatchRequestFunction())(original, authority));
                shimmer.unwrap(plugin.moduleExports, 'connect');
                return client;
            };
        };
    }
    getPatchRequestFunction() {
        const plugin = this;
        return (original, authority) => {
            return function patchedRequest(headers) {
                // Do not trace ourselves
                if (headers['x-opencensus-outgoing-request']) {
                    return original.apply(this, arguments);
                }
                const request = original.apply(this, arguments);
                plugin.tracer.wrapEmitter(request);
                const traceOptions = {
                    name: `${headers[':method'] || 'GET'} ${headers[':path']}`,
                    kind: 'CLIENT',
                };
                // Checks if this outgoing request is part of an operation by checking
                // if there is a current root span, if so, we create a child span. In
                // case there is no root span, this means that the outgoing request is
                // the first operation, therefore we create a root span.
                if (!plugin.tracer.currentRootSpan) {
                    return plugin.tracer.startRootSpan(traceOptions, plugin.getMakeHttp2RequestTraceFunction(request, headers, authority, plugin));
                }
                else {
                    const span = plugin.tracer.startChildSpan(traceOptions.name, traceOptions.kind);
                    return (plugin.getMakeHttp2RequestTraceFunction(request, headers, authority, plugin))(span);
                }
            };
        };
    }
    getMakeHttp2RequestTraceFunction(request, headers, authority, plugin) {
        return (span) => {
            if (!span)
                return request;
            const setter = {
                setHeader(name, value) {
                    headers[name] = value;
                }
            };
            const propagation = plugin.tracer.propagation;
            if (propagation) {
                propagation.inject(setter, span.spanContext);
            }
            request.on('response', (responseHeaders) => {
                span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_STATUS_CODE, `${responseHeaders[':status']}`);
                span.status =
                    Http2Plugin.convertTraceStatus(+responseHeaders[':status']);
            });
            request.on('end', () => {
                const userAgent = headers['user-agent'] || headers['User-Agent'] || null;
                span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_HOST, url.parse(authority).host);
                span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_METHOD, `${headers[':method']}`);
                span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_PATH, `${headers[':path']}`);
                span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_ROUTE, `${headers[':path']}`);
                if (userAgent) {
                    span.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_USER_AGENT, `${userAgent}`);
                }
                span.addMessageEvent('MessageEventTypeSent', uuid.v4().split('-').join(''));
                span.end();
            });
            request.on('error', (err) => {
                span.addAttribute(instrumentation_http_1.HttpPlugin.ATTRIBUTE_HTTP_ERROR_NAME, err.name);
                span.addAttribute(instrumentation_http_1.HttpPlugin.ATTRIBUTE_HTTP_ERROR_MESSAGE, err.message);
                span.end();
            });
            return request;
        };
    }
    getPatchCreateServerFunction() {
        const plugin = this;
        return (original) => {
            return function patchedCreateServer() {
                const server = original.apply(this, arguments);
                shimmer.wrap(server.constructor.prototype, 'emit', plugin.getPatchEmitFunction());
                shimmer.unwrap(plugin.moduleExports, 'createServer');
                shimmer.unwrap(plugin.moduleExports, 'createSecureServer');
                return server;
            };
        };
    }
    getPatchEmitFunction() {
        const plugin = this;
        return (original) => {
            return function patchedEmit(event, stream, headers) {
                if (event !== 'stream') {
                    return original.apply(this, arguments);
                }
                const propagation = plugin.tracer.propagation;
                const getter = {
                    getHeader(name) {
                        return headers[name];
                    }
                };
                const traceOptions = {
                    name: headers[':path'],
                    kind: 'SERVER',
                    spanContext: propagation ? propagation.extract(getter) : null
                };
                // Respond is called in a stream event. We wrap it to get the sent
                // status code.
                let statusCode = null;
                const originalRespond = stream.respond;
                stream.respond = function () {
                    // Unwrap it since respond is not allowed to be called more than once
                    // per stream.
                    stream.respond = originalRespond;
                    statusCode = arguments[0][':status'];
                    return stream.respond.apply(this, arguments);
                };
                return plugin.tracer.startRootSpan(traceOptions, rootSpan => {
                    if (!rootSpan)
                        return original.apply(this, arguments);
                    plugin.tracer.wrapEmitter(stream);
                    const originalEnd = stream.end;
                    stream.end = function () {
                        stream.end = originalEnd;
                        const returned = stream.end.apply(this, arguments);
                        const userAgent = (headers['user-agent'] || headers['User-Agent'] ||
                            null);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_HOST, `${headers[':authority']}`);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_METHOD, `${headers[':method']}`);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_PATH, `${headers[':path']}`);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_ROUTE, `${headers[':path']}`);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_USER_AGENT, userAgent);
                        rootSpan.addAttribute(Http2Plugin.ATTRIBUTE_HTTP_STATUS_CODE, `${statusCode}`);
                        rootSpan.status = Http2Plugin.convertTraceStatus(statusCode);
                        rootSpan.addMessageEvent('MessageEventTypeRecv', uuid.v4().split('-').join(''));
                        rootSpan.end();
                        return returned;
                    };
                    return original.apply(this, arguments);
                });
            };
        };
    }
}
exports.Http2Plugin = Http2Plugin;
const plugin = new Http2Plugin();
exports.plugin = plugin;
//# sourceMappingURL=http2.js.map